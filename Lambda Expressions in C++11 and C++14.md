# Lambda Expression C++11

lambda expression is a shorhand syntax for creating a function object.  
__<font color = 'red'> a function object in C++ is actually a  
struct or class with the parenthesis operator overloaded.</font>__

```c++
auto isOdd = [](int x){return x % 2}
auto a = isOdd(3); // returns true
// The example above means lambda function is actually a function object. This include declare, define, instantiate a function object.
```
The example below will use the count_if member function in Algorithm library with structure type function object / lambda function.  
```c++
#include <iostream>
#include <vector>

struct isOdd
{
	bool operator()(int x){ return x % 2;} // operator overloaded makes this structure a function object
}

int main()
{
	std::vector<int> v {3, 4, 2, 1, 56, 2, 4, 65, 2, 9, 8, 5, 7}
	std::count_if(begin(v), end(v), isOdd()); // using function object
	auto c = std::count_if(begin(v), end(v), [](int x){return x % 2});
	std::cout << c;
}

```
__Closure type__  
A closure type is the type generated by the compiler from the lambda expression
```c++
// type of isOdd
auto isOdd = [](int x){ return x % 2; }
```

__Lambda Capture__  
[] called a capture operator, used to passing variables to lambda function  
Capture using brackets is called explicit capture.  

<font color='red'>The explicit capture specifies how and what to capture, by reference or by value.</font>
_the default is capture by value, so the value will copied into the lambda function. By using the reference capture, that will change the variable itself after the excution of lambda_

```c++
#include <iostream>
#include <vector>

int main()
{
	std::vector<int> v {3, 4, 2, 1, 56, 2, 4, 65, 2, 9, 8, 5, 7}
	auto mult = 3;
	auto isMultipleOf = [mult](int x) {return x % mult;}
	// capture a outer variable using explicit capture.
	auto c = std::count_if(begin(v), end(v), isMultipleOf);
	std::cout << c;
}

```
__Example of C++ 'for_each' member function in algorithm header__  

```c++
int main()
{
	std::vector<int> v {3, 4, 2, 1, 56, 2, 4, 65, 2, 9, 8, 5, 7}
	auto sum = 0;
	// need to capture sum by reference, otherwise error occurs
	std::for_each(begin(v), end(v), [&sum](int x){ sum += x;});
	
	std::cout << c;
}

```

__Default Capture__  

When we just put '=' in the capture operator, the compiler will automatically capture the variables needed in the lambda scope and copy them in to lambda by value.  

When we just put '&' in the capture operator, the compiler will automatically capture the variables needed in the lambda scope and use them by reference.  

or you can mix them, [=, &sum] this means capture all variables by value, but capture 'sum' by reference.  


# Lambda Expression C++14  

__Init Capture__  

The __init capture__ allows naming and initializing of capture  

```c++
// explicit capture by reference
std::vector<int> col{...};
int sum = 0;
std::for_each(begin(col), end(col), [&mySum = Sum](int x) { mySum += x; })

```
__<font color = 'red'>The below example explain the std::move function</font>__  
```c++
#include <iostream>
#include <utility>
#include <vector>
#include <string>
int main()
{
    std::string str = "Hello";
    std::vector<std::string> v;
 
    // uses the push_back(const T&) overload, which means
    // we'll incur the cost of copying str
    v.push_back(str);
    std::cout << "After copy, str is \"" << str << "\"\n";
 
    // uses the rvalue reference push_back(T&&) overload,
    // which means no strings will copied; instead, the contents
    // of str will be moved into the vector.  This is less
    // expensive, but also means str might now be empty.
    v.push_back(std::move(str));
    std::cout << "After move, str is \"" << str << "\"\n";
 
    std::cout << "The contents of the vector are \"" << v[0]
                                         << "\", \"" << v[1] << "\"\n";
}
```
A more complicated example of __Init Capture__  
```c++
int main()
{
	std::vector<int> v {...};
	auto sum = 0;
	auto fn = [myVec = std::move(v),  &sum] () {
		std::for_each(begin(myVec), end(myVec), [&mySum = sum](int x) {mySum += x; })
	}
}
```

__Generic Lambda__  

The generic lambda is a lambda which uses auto in its parameter list.  
```c++
#include <iostream>
#include <vector>
#include <algorithm>

struct isEven
{
	template<typename T>
	bool operator()(T x) { return !(x % 2); }
};

template<typename Col>
long fun(Col const& col)
{
	auto c = std::count_if(begin(col), end(col), [](typename Col::value_type x) { return !(x % 2); })
	auto c = std::count_if(begin(col), end(col), isEven);
	return c;
}

int main(){}

```








